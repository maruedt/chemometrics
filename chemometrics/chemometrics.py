"""A (spectroscopic) chemometric library

Provides a number of functions for data pretreatment, plotting and regression.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm
import scipy.linalg as linalg


def plot_colored_series(Y, x=None, reference=None):
    r"""
    Plot matrix colored by position or `reference`

    Generate a line plot with `x` on x-axis and one or multiple dataseries
    `Y`. The lines are either colored by position in the matrix `Y` or by
    value in the `reference` matrix.

    Parameters
    ----------
    Y : (n, m) ndarray
        Matrix containing data series to plot. The function expects. ``n``
        datapoints in ``m``series.
    x : {None, (n,) ndarray}
        Location on x-axis
    reference : {None (default), (m,) ndarray}
        Reference values to color data series by. If None, the series are
        colored by the position in the second dimension of matrix ``Y``.

    Returns
    -------
    lines : list
        A list of line objects generated by plotting the spectra.
    """
    # define number of input series for line plot
    if (Y.ndim > 1):
        n_series = Y.shape[1]
    else:
        n_series = 1
    if x is None:
        x = np.arange(Y.shape[0])
    # if no reference is given a dummy reference is needed (sequential
    # coloring)
    if reference is None:
        reference = np.arange(n_series)
    myMapper = matplotlib.cm.ScalarMappable(cmap='viridis')
    colors = myMapper.to_rgba(reference)
    lines = []
    for i in range(n_series):
        line_i = plt.plot(x, Y[:, i], color=colors[i, :])
        lines.append(line_i[0])
    return lines


def plot_svd(D, n_comp=5, n_eigenvalues=20):
    r"""
    Plot SVD-matrices in three subplots.

    Perform a Singular Value Decomposition (SVD) and plot the three matrices
    in three subplots. The number of singular vectors shown is ``n_comp``. The
    left subplot contains the left singular vectors, the middle subplot the
    singular values, the right subplot the right singular vectors. The
    function is a useful tool to get first insights into a data set. It helps
    to evaluate which components contain information and which mainly noise.
    Compared to Principal Component Analysis (PCA), the singular vectors are
    normalized and scaling results from the eigenvalues.

    Parameters
    ----------
    D : (n, m) ndarray
        Matrix containing data to plot and analyze. The function expects. ``n``
        samples with ``m`` signals (e.g. wavelengths, measurements).

    n_comp : int
        Number of singular vectors to plot.

    n_eigenvalues : int

    Returns
    -------
    fig : figure
        A list of line objects generated by plotting the spectra.
    """
    u, s, vh = linalg.svd(D)

    fig = plt.figure(figsize=(15, 5))
    plt.subplot(131)
    plt.plot(u[:, :n_comp])
    plt.subplot(132)
    for i in range(n_eigenvalues):
        if i < n_comp:
            plt.plot(i, s[i], 'o')
        else:
            plt.plot(i, s[i], 'ok')
    plt.gca().set_yscale('log')
    plt.subplot(133)
    plt.plot(vh.T[:, :n_comp])

    return fig


def generate_spectra(n_wl, n_band, bandwidth):
    r"""
    Generate a dummy spectra with n_band
    """
    wl = np.arange(n_wl)
    spectra = np.zeros(n_wl)
    for i in range(n_band):
        center_wl = np.random.choice(wl)
        bandwidth_i = np.random.gamma(shape=bandwidth, scale=bandwidth)
        intensity = np.random.poisson(lam=5)*np.random.normal(loc=1, scale=0.2)
        current_spectra = intensity * _gaussian_fun(wl, center_wl, bandwidth_i)
        spectra += current_spectra
    return spectra


def generate_background(n_wl, rel_lengthscale=0.5, size=1):
    r"""
    Generate dummy background.

    Generate dummy background by drawing samples from a gaussian process.
    """
    mean = np.zeros(n_wl)
    x = np.arange(n_wl)[:, None]
    dist = x.T - x
    cov = np.exp(-(dist / (n_wl * rel_lengthscale))**2)

    # draw a few samples from gaussian process as data
    background = np.random.multivariate_normal(mean, cov, size=size)
    return background


def _gaussian_fun(x, mu, sigma):
    r"""
    Generates Gaussian profile
    """
    return np.exp(-((x - mu) / sigma) ** 2 / 2)
